/***
 *If this code runs it was created by Evgenii Sokol.
 *If it doesn't work, I don't know who was created it.
 ***/

package com.turbosokol.TimeTask.repository.datasource

import com.turbosokol.TimeTask.database.TaskDatabase
import com.turbosokol.TimeTask.repository.data.TaskDto

// Using basic SQLDelight without coroutines extensions

/**
 * Android-specific SQLDelight implementation of LocalTaskDataSource
 */
class SqlDelightLocalTaskDataSource(
    private val database: TaskDatabase
) : LocalTaskDataSource {

    override suspend fun getAllTasks(): List<TaskDto> {
        return database.taskDatabaseQueries.selectAll().executeAsList().map { task ->
            TaskDto(
                id = task.id.toInt(),
                title = task.title,
                isActive = task.is_active == 1L,
                startTimeStamp = task.start_time_stamp,
                timeSeconds = task.time_seconds,
                timeHours = task.time_hours,
                color = task.color
            )
        }
    }

    override suspend fun getTaskById(id: Int): TaskDto? {
        return database.taskDatabaseQueries.selectById(id.toLong()).executeAsOneOrNull()?.let { task ->
            TaskDto(
                id = task.id.toInt(),
                title = task.title,
                isActive = task.is_active == 1L,
                startTimeStamp = task.start_time_stamp,
                timeSeconds = task.time_seconds,
                timeHours = task.time_hours,
                color = task.color
            )
        }
    }

    override suspend fun upsertTask(task: TaskDto): TaskDto {
        return if (task.id == 0) {
            // Insert new task - ID will be auto-generated by SQLite AUTOINCREMENT
            database.taskDatabaseQueries.insertTask(
                title = task.title,
                is_active = if (task.isActive) 1L else 0L,
                start_time_stamp = task.startTimeStamp,
                time_seconds = task.timeSeconds,
                time_hours = task.timeHours,
                color = task.color
            )
            
            // Get the generated ID
            val generatedId = database.taskDatabaseQueries.getLastInsertedId().executeAsOne().toInt()
            
            // Return task with the generated ID
            task.copy(id = generatedId)
        } else {
            // Update existing task - use provided ID
            database.taskDatabaseQueries.updateTask(
                title = task.title,
                is_active = if (task.isActive) 1L else 0L,
                start_time_stamp = task.startTimeStamp,
                time_seconds = task.timeSeconds,
                time_hours = task.timeHours,
                color = task.color,
                id = task.id.toLong()
            )
            
            // Return task with original ID
            task
        }
    }

    override suspend fun upsertTasks(tasks: List<TaskDto>) {
        tasks.forEach { task ->
            upsertTask(task)
        }
    }

    override suspend fun deleteTask(id: Int) {
        database.taskDatabaseQueries.deleteTaskById(id.toLong())
    }

    override suspend fun deleteAllTasks() {
        database.taskDatabaseQueries.deleteAllTasks()
    }
}